#!/usr/bin/env python

from async_dns import (
	core as adns_core, server as adns_server,
	resolver as adns_resolver )
from async_dns.core import cache as adns_cache
import os, sys, asyncio, logging, socket, signal, hashlib as hl


class LogMessage:
	def __init__(self, fmt, a, k): self.fmt, self.a, self.k = fmt, a, k
	def __str__(self): return self.fmt.format(*self.a, **self.k) if self.a or self.k else self.fmt

class LogStyleAdapter(logging.LoggerAdapter):
	def __init__(self, logger, extra=None):
		super(LogStyleAdapter, self).__init__(logger, extra or {})
	def log(self, level, msg, *args, **kws):
		if not self.isEnabledFor(level): return
		log_kws = {} if 'exc_info' not in kws else dict(exc_info=kws.pop('exc_info'))
		msg, kws = self.process(msg, kws)
		self.logger._log(level, LogMessage(msg, args, kws), (), **log_kws)

get_logger = lambda name: LogStyleAdapter(logging.getLogger(name))

def log_init(name, debug=False):
	global log
	log_fmt = '{name} {levelname:5} :: {message}'
	if debug: log_fmt = '{asctime} :: ' + log_fmt
	log_fmt = logging.Formatter(log_fmt, style='{')
	log_handler = logging.StreamHandler(sys.stderr)
	log_handler.setLevel(logging.DEBUG if debug else logging.WARNING)
	log_handler.setFormatter(log_fmt)
	logging.root.addHandler(log_handler)
	logging.root.setLevel(0)
	log = get_logger(f'{name}.main')


class HashTestResolver:

	hash_person = 'dnstd.1'.encode()

	def __init__(self, hash_key=None, cache_ttl=180):
		self.hash_key, self.cache_ttl = hash_key.encode() or b'', cache_ttl

	async def query_with_cache(self, fqdn, qtype, timeout=None, tick=5):
		try: return await self.query_hash(fqdn, qtype)
		except:
			log.exception('Failed to resove fqdn/qtype: {!r} / {!r}', fqdn, qtype)
			raise

	async def query_hash(self, fqdn, qtype):
		# http://www-inf.int-evry.fr/~hennequi/CoursDNS/NOTES-COURS_eng/msg.html
		fqdn = fqdn.rstrip('.')
		msg = adns_core.DNSMessage(ra=False)
		msg.qd.append(adns_core.Record(
			adns_core.REQUEST, name=fqdn, qtype=qtype))
		if qtype not in [adns_core.types.A, adns_core.types.AAAA]:
			msg.r = 3 # NXDOMAIN response
		else:
			msg.aa = 1 # authoritative answer
			s = hl.blake2s( fqdn.encode(),
				key=self.hash_key, person=self.hash_person ).digest()
			addr = (
				socket.inet_ntop(socket.AF_INET, s[:4])
				if qtype == adns_core.types.A else
				socket.inet_ntop(socket.AF_INET6, s[:16]) )
			msg.an.append(adns_core.Record(
				name=fqdn, data=addr, qtype=qtype, ttl=self.cache_ttl ))
		return msg, False # msg, from_cache

async def bind_resolver(resolver, host, port):
	loop = asyncio.get_event_loop()

	tcp_server = await loop.create_server(
		lambda: adns_server.DNSProtocol(resolver), host, port )
	for sock in tcp_server.sockets:
		log.debug('Listening on TCP addr {} port {} ', *(sock.getsockname()[:2]))

	host_list = ([host] if isinstance(host, str) else host) if host else ['::']
	for host_bind in host_list:
		transport, protocol = await loop.create_datagram_endpoint(
			lambda: adns_server.DNSDatagramProtocol(resolver),
			local_addr=(host_bind, port) )
		log.debug( 'Listening on UDP addr'
			' {} port {} ', *(transport.get_extra_info('sockname')[:2]) )


def main(args=None):
	import argparse, textwrap
	dd = lambda text: (textwrap.dedent(text).strip('\n') + '\n').replace('\t', '  ')
	fill = lambda s,w=90,ind='',ind_next='  ',**k: textwrap.fill(
		s, w, initial_indent=ind, subsequent_indent=ind if ind_next is None else ind_next, **k )

	parser = argparse.ArgumentParser(
		formatter_class=argparse.RawTextHelpFormatter,
		description=dd('''
			Testing DNS daemon that returns responses
				with addresses generated by hashing queried name.
			Only handles A and AAAA queries, returns autoritative responses.'''))
	parser.add_argument('-b', '--bind',
		metavar='(host)(:port)', default='127.0.0.1:53',
		help=dd('''
			IPv4/IPv6 address and optional TCP+UDP port to bind daemon to.
			Examples: :53, 1.2.3.4:5533, 127.0.0.1, [::1]:55, fd00::1, localhost:5555
			Default: %(default)s'''))
	parser.add_argument('-k', '--hash-key', metavar='string', help=dd(f'''
		Arbitrary string value (32B max) to be used as key=
			for blake2s hash function to produce address result from queried name.
		person= value for hash will be {HashTestResolver.hash_person.decode()!r}, first bytes
			of hash for name will be returned as address after inet_ntop conversion.'''))
	parser.add_argument('-c', '--cache-ttl',
		metavar='n', type=int, default=300,
		help='Cache TTL value (seconds) in all returned responses. Default: %(default)s')
	parser.add_argument('-d', '--debug', action='store_true', help='Verbose operation mode.')
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	log_init('dnstd', opts.debug)
	logging.getLogger('async_dns.core').handlers.clear() # see async_dns.core.logger

	for sig in 'int term'.upper().split():
		signal.signal(getattr(signal, f'SIG{sig}'), lambda sig,frm: sys.exit(0))

	bind_addr = adns_core.Address(opts.bind, allow_domain=True)
	resolver = HashTestResolver(opts.hash_key, opts.cache_ttl)

	loop = asyncio.get_event_loop()
	loop.run_until_complete(bind_resolver(resolver, bind_addr.host, bind_addr.port))
	log.debug('Starting resolver eventloop...')
	loop.run_forever()
	log.debug('Finished')

if __name__ == '__main__': sys.exit(main())
