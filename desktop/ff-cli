#!/usr/bin/env python

import os, sys, re, configparser, json, pathlib as pl


def get_profile_dir(profile, ff_home):
	if profile:
		if profile.startswith('/'): return pl.Path(profile)
		profile = profile.lower() # for ci comparisons
	paths, ff_home = list(), pl.Path(ff_home).expanduser()
	(conf_list := configparser.ConfigParser()).read(ff_home / 'profiles.ini')
	for k, conf in conf_list.items():
		if not k.startswith('Profile'): continue
		try: p = ff_home / conf['Path']
		except KeyError: continue
		if ( profile is not None and
				conf.get('Name', fallback='').strip().lower() == profile ): return p
		if profile: paths.append(p); continue # candidates for string-match
		if conf.getboolean('Default'): return p
	for p in paths:
		if profile in p.name.lower(): return p

def mozlz4_read(p, bs_max=8 * 2**20):
	# This is a different format than lz4 tool produces, and not just wrt header
	import lz4.block # https://python-lz4.readthedocs.io/
	with p.open('rb') as src: data = src.read(bs_max + 1)
	if len(data) >= bs_max: # intended for small json files only
		raise MemoryError(f'File size >bs_max limit ({bs_max/2**20:,.1f} MiB)')
	if (hdr := data[:8]) != b'mozLz40\0':
		raise ValueError(f'Incorrect file header magic: {hdr}')
	return lz4.block.decompress(data[8:])


def main(args=None):
	import argparse, textwrap
	dd = lambda text: re.sub( r' \t+', ' ',
		textwrap.dedent(text).strip('\n') + '\n' ).replace('\t', '  ')
	parser = argparse.ArgumentParser(
		formatter_class=argparse.RawTextHelpFormatter,
		description='Tool to interact with firefox browser and its profile data.')
	parser.add_argument('-H', '--ff-home', metavar='path', default='~/.mozilla/firefox',
		help='Firefox-like browser home directory to use, if needed. Default: %(default)s')
	parser.add_argument('-P', '--profile', metavar='name/key/path', help=dd('''
		Full firefox profile name, profile directory name/fragment,
			or a full path to profile dir (default: find Default=1 profile).'''))
	cmds = parser.add_subparsers(title='Commands',
		description='Use -h/--help with these to list command-specific options.', dest='call')
	cmd = cmds.add_parser('tabs',
		formatter_class=argparse.RawTextHelpFormatter, help='List currently opened tabs')
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	def _profile_path():
		if not (p := get_profile_dir(opts.profile, opts.ff_home)):
			parser.error( 'Failed to find default/specified -P/--profile'
				f' [ {opts.profile} ] in -H/--ff-home dir [ {opts.ff_home} ]' )
		return p

	match opts.call:

		case 'tabs':
			p = _profile_path() / (fn := 'sessionstore-backups/recovery.jsonlz4')
			if not p.exists(): parser.error(f'Missing profile session-file: {fn}')
			n, session = 0, json.loads(mozlz4_read(p))
			for win in session['windows']:
				for tab in win.get('tabs', list()):
					if tab.get('hidden'): continue
					if not (entries := tab.get('entries')): continue
					last_entry = entries[tab['index'] - 1] # index is 1-base there
					title, url = (last_entry.get(k) for k in ['title', 'url'])
					n += 1; print(f'\n[Tab {n}] {title}\n  {url}')
			if n: print()

		case None: parser.error('No command specified')
		case _: parser.error(f'Unrecognized command: {opts.call}')

if __name__ == '__main__': sys.exit(main())
