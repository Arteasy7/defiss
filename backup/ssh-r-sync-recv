#!/usr/bin/env python3

import itertools as it, operator as op, functools as ft
import os, sys, contextlib, subprocess, socket
import hashlib, math, json, base64, signal, time
import tempfile, pathlib as pl


p_fmt = lambda fmt,*a,**k: (
	[fmt.format(*a,**k)] if isinstance(fmt, str)
		and (a or k) else [[fmt, *a], k] )
p = lambda fmt,*a,**k: print(*p_fmt(fmt,*a,**k), file=sys.stderr, flush=True)


class SSHRsyncReceiverConfig:
	# recv_port_* settings should be same on server/client
	recv_port_range = 6000, 6999
	recv_port_retries = 4
	recv_port_hash_key = b'J\xbc\xed\xa3\xa5\x02E(\xde\xdc#h\xa4\xa5\xa4t'

	hs_hello = b'ssh-r-sync o/ 1'
	hs_timeout = 5.0
	hs_key_size = 64

class SSHRsyncError(Exception):
	def __init__(self, *args):
		super().__init__(str(p_fmt(*args)[0]))


def hash_to_int(name, retry, n_max, **blake2_kws):
	'Returns integer hash within n_max range from name/retry values.'
	assert n_max > 0, n_max
	n_bits = math.ceil(math.log(n_max + 1, 2))
	n_bytes = math.ceil(n_bits / 8)
	mac = retry.to_bytes(1, 'big') + name.encode()
	for n in range(1000):
		mac = hashlib.blake2b(mac, **blake2_kws).digest()
		for o in range(0, 8//n_bytes):
			n = int.from_bytes(mac[o*n_bytes:(o+1)*n_bytes], 'big')
			if n_bits % 8: n >>= 8 - n_bits % 8
			if n <= n_max: return n # (n % n_max) would add bias for small values
	raise ValueError('Failed to get int within range after many hashes')

b64_str = lambda v: base64.urlsafe_b64encode(v).decode()
b64_bytes = lambda v: base64.urlsafe_b64decode(v.encode())

@contextlib.contextmanager
def err_timeout(timeout, err_t, *err_args):
	def timeout_handler(sig, frm): raise err_t(*err_args)
	handler_prev = signal.signal(signal.SIGALRM, timeout_handler)
	delay, interval = signal.setitimer(signal.ITIMER_REAL, timeout)
	assert not delay or interval
	try: yield
	finally:
		signal.setitimer(signal.ITIMER_REAL, 0)
		if handler_prev: signal.signal(signal.SIGALRM, handler_prev)

def proc_close(proc, wait=1, wait_base=0.3):
	if not proc or proc.poll() is not None: return
	close_ops = [proc.terminate, proc.kill]
	if proc.stdin: close_ops = [proc.stdin.close] + close_ops
	if isinstance(wait, (int, float)) and wait > 0:
		wait = list(n*wait for n, func in enumerate(close_ops, 1))
	wait = dict(enumerate(wait or list()))
	for n, func in enumerate(close_ops):
		with contextlib.suppress(OSError): func()
		with contextlib.suppress(subprocess.TimeoutExpired):
			proc.wait(wait.get(n, wait_base))
			break


def main(args=None):
	conf = SSHRsyncReceiverConfig()

	import argparse, textwrap

	dedent = lambda text: (textwrap.dedent(text).strip('\n') + '\n').replace('\t', '  ')
	class SmartHelpFormatter(argparse.HelpFormatter):
		def __init__(self, *args, **kws):
			return super().__init__(*args, **kws, width=100)
		def _fill_text(self, text, width, indent):
			if '\n' not in text: return super()._fill_text(text, width, indent)
			return ''.join( indent + line
				for line in text.replace('\t', '  ').splitlines(keepends=True) )
		def _split_lines(self, text, width):
			return super()._split_lines(text, width)\
				if '\n' not in text else dedent(text).splitlines()

	parser = argparse.ArgumentParser(
		formatter_class=SmartHelpFormatter,
		description=dedent('''
			Receiver script for ssh sessions from ssh-r-sync.
			Should be run after successful ssh auth to check reverse-tunnel setup,
				perform any necessary maintenance on destination path and run rsync client.'''),
		epilog=dedent('''
			sshd_config snippet to set this script for backup-user command:

				Match User backup
					# GatewayPorts yes
					PasswordAuthentication no
					X11Forwarding no
					AllowAgentForwarding no
					PermitTTY no
					PermitTunnel no
					AllowStreamLocalForwarding no
					AllowTcpForwarding remote
					ForceCommand ~/ssh-r-sync-recv -m -- /mnt/backups

			Any cli opts of this script should be added to ForceCommand.
			Authentication is done via usual lines in ~backup/.ssh/authorized_keys'''))
	# XXX: allow to use as shell, with backup_dir set to home-dir
	parser.add_argument('backup_dir', help='Destination backup directory path.')
	parser.add_argument('-r', '--rsync', metavar='path',
		help='Path to custom rsync binary, e.g. one with all necessary posix caps enabled.')
	parser.add_argument('-m', '--manifest',
		nargs='?', metavar='name', const='_manifest.txt',
		help='Generate manifest file with specified name'
				' (default: %(default)s) in the synced directories.'
			' Created by single "find -printf ..." command with'
				' custom format, including various file/path stats/attributes.')
	# XXX: option for touching/removing backup-done file
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	ssh_recv = open(sys.stdin.fileno(), 'rb', 0)
	ssh_send = open(sys.stdout.fileno(), 'wb', 0)
	sys.stdin = sys.stdout = None

	hs_timeout_ctx = ft.partial( err_timeout,
		conf.hs_timeout, SSHRsyncError, 'Timeout waiting for receiver' )

	with hs_timeout_ctx(): ssh_send.write(conf.hs_hello + b'\n')
	with hs_timeout_ctx(): hello = ssh_recv.readline().rstrip(b'\n')
	if hello != conf.hs_hello:
		raise SSHRsyncError( 'Hello-string mismatch:'
			' local={!r} remote={!r}', conf.hs_hello, hello )

	with hs_timeout_ctx(): info = ssh_recv.readline()
	info = json.loads(info)
	tun_ports = set(
		(conf.recv_port_range[0] + hash_to_int( info['name'], attempt,
			conf.recv_port_range[1] - conf.recv_port_range[0], key=conf.recv_port_hash_key ))
		for attempt in range(conf.recv_port_retries+1) )
	if info['port'] not in tun_ports:
		raise SSHRsyncError( 'Tunnel-port mismatch:'
			' remote={!r} local-set={!r}', info['port'], tun_ports )
	info['key'] = b64_bytes(info['key'])

	# XXX: backup dir handling/rotation
	bak_path = pl.Path(opts.backup_dir).resolve()

	rsync_cmd = pl.Path(opts.rsync).resolve() if opts.rsync else 'rsync'
	rsync_user, rsync_key, rsync_mod, rsync_su =\
		(info[f'rsync_{k}'] for k in 'user key mod su'.split())
	rsync_port = info['port']
	rsync_opts = [
		*(['-HaAXS', '--super', '--numeric-ids'] if rsync_su else ['-rltHE']),
		( '--skip-compress='
			r'gz/bz2/t\[gb\]z/tbz2/xz/lzma/7z/zip/rar'
			r'/rpm/deb/iso'
			r'/jpg/gif/png/mov/avi/og\[gv\]/mkv/webm/mp\[34g\]/flv/flac/ape/pdf/djvu' ) ]
	rsync_src = f'rsync://{rsync_user}@localhost:{rsync_port}/{rsync_mod}/.'
	rsync_dst = str(bak_path / '.')

	key_recv = hashlib.blake2b(info['key'], person=b'server', key=conf.hs_hello).digest()
	key_push = hashlib.blake2b(info['key'], person=b'client', key=conf.hs_hello).digest()
	assert len(key_recv) == len(key_push) == conf.hs_key_size, [len(key_recv), len(key_push)]

	with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock_conn:
		sock_conn.settimeout(conf.hs_timeout)
		sock_conn.connect(('localhost', rsync_port))
		key = sock_conn.recv(conf.hs_key_size)
		if len(key) != conf.hs_key_size or key != key_push:
			raise SSHRsyncError('ssh/socket mismatch (len={}/{})', len(key), conf.hs_key_size)
		sock_conn.send(key_recv)

	cmd = ssh_recv.readline().rstrip(b'\n')
	if cmd != b'start': raise SSHRsyncError('Invalid/missing backup command: {!r}', cmd)

	rsync = subprocess.Popen(
		[rsync_cmd] + rsync_opts + [rsync_src, rsync_dst],
		env=dict(RSYNC_PASSWORD=rsync_key) ) # XXX: check popen kws
	rsync_err = rsync.wait()
	if rsync_err != 0:
		raise SSHRsyncError('Rsync process exited with non-0 code: {}', rsync_err)

	if opts.manifest:
		with tempfile.NamedTemporaryFile(
				dir=bak_path, prefix=opts.manifest + '.', delete=False ) as tmp:
			try:
				subprocess.run(
					['find', '-printf', '%P :: %Y:%l :: %U:%G:%m :: %s :: %T@\n'],
					stdout=tmp, cwd=rsync_dst, check=True)
				os.rename(tmp.name, bak_path / opts.manifest)
			finally:
				with contextlib.suppress(OSError): os.unlink(tmp.name)

	ssh_send.write(b'done\n')
	ssh_send.close()

if __name__ == '__main__': sys.exit(main())
