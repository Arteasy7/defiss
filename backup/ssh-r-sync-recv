#!/usr/bin/env python3

import itertools as it, operator as op, functools as ft
import os, sys, contextlib, collections, subprocess, socket
import hashlib, math, json, base64, signal, time
import tempfile, pathlib as pl


p_fmt = lambda fmt,*a,**k: (
	[fmt.format(*a,**k)] if isinstance(fmt, str)
		and (a or k) else [[fmt, *a], k] )
p = lambda fmt,*a,**k: print(*p_fmt(fmt,*a,**k), file=sys.stderr, flush=True)


class SSHRsyncReceiverConfig:
	# recv_port_* settings should be same on server/client
	recv_port_range = 6000, 6999
	recv_port_retries = 4
	recv_port_hash_key = b'J\xbc\xed\xa3\xa5\x02E(\xde\xdc#h\xa4\xa5\xa4t'

	hs_hello = b'ssh-r-sync o/ 1'
	hs_timeout = 5.0
	hs_key_size = 64

class SSHRsyncError(Exception):
	def __init__(self, *args):
		super().__init__(str(p_fmt(*args)[0]))


def hash_to_int(name, retry, n_max, **blake2_kws):
	'Returns integer hash within n_max range from name/retry values.'
	assert n_max > 0, n_max
	n_bits = math.ceil(math.log(n_max + 1, 2))
	n_bytes = math.ceil(n_bits / 8)
	mac = retry.to_bytes(1, 'big') + name.encode()
	for n in range(1000):
		mac = hashlib.blake2b(mac, **blake2_kws).digest()
		for o in range(0, 8//n_bytes):
			n = int.from_bytes(mac[o*n_bytes:(o+1)*n_bytes], 'big')
			if n_bits % 8: n >>= 8 - n_bits % 8
			if n <= n_max: return n # (n % n_max) would add bias for small values
	raise ValueError('Failed to get int within range after many hashes')

b64_str = lambda v: base64.urlsafe_b64encode(v).decode()
b64_bytes = lambda v: base64.urlsafe_b64decode(v.encode())

@contextlib.contextmanager
def err_timeout(timeout, err_t, *err_args):
	def timeout_handler(sig, frm): raise err_t(*err_args)
	handler_prev = signal.signal(signal.SIGALRM, timeout_handler)
	delay, interval = signal.setitimer(signal.ITIMER_REAL, timeout)
	assert not delay or interval
	try: yield
	finally:
		signal.setitimer(signal.ITIMER_REAL, 0)
		if handler_prev: signal.signal(signal.SIGALRM, handler_prev)

def proc_close(proc, wait=1, wait_base=0.3):
	if not proc or proc.poll() is not None: return
	close_ops = [proc.terminate, proc.kill]
	if proc.stdin: close_ops = [proc.stdin.close] + close_ops
	if isinstance(wait, (int, float)) and wait > 0:
		wait = list(n*wait for n, func in enumerate(close_ops, 1))
	wait = dict(enumerate(wait or list()))
	for n, func in enumerate(close_ops):
		with contextlib.suppress(OSError): func()
		with contextlib.suppress(subprocess.TimeoutExpired):
			proc.wait(wait.get(n, wait_base))
			break


SSHPipe = collections.namedtuple('SSHPipe', 'send recv')
RsyncInfo = collections.namedtuple('RsyncInfo', 'user key mod su')

def get_rsync_info(conf, ssh):
	hs_timeout_ctx = ft.partial( err_timeout,
		conf.hs_timeout, SSHRsyncError, 'Timeout waiting for receiver' )

	with hs_timeout_ctx(): ssh.send.write(conf.hs_hello + b'\n')
	with hs_timeout_ctx(): hello = ssh.recv.readline().rstrip(b'\n')
	if hello != conf.hs_hello:
		raise SSHRsyncError( 'Hello-string mismatch:'
			' local={!r} remote={!r}', conf.hs_hello, hello )

	with hs_timeout_ctx(): info = ssh.recv.readline()
	info = json.loads(info)
	tun_ports = set(
		(conf.recv_port_range[0] + hash_to_int( info['name'], attempt,
			conf.recv_port_range[1] - conf.recv_port_range[0], key=conf.recv_port_hash_key ))
		for attempt in range(conf.recv_port_retries+1) )
	if info['port'] not in tun_ports:
		raise SSHRsyncError( 'Tunnel-port mismatch:'
			' remote={!r} local-set={!r}', info['port'], tun_ports )
	rsync_port, rsync_info = info['port'], RsyncInfo(**info['rsync'])
	key_base = b64_bytes(info['key'])

	key_recv = hashlib.blake2b(key_base, person=b'server', key=conf.hs_hello).digest()
	key_push = hashlib.blake2b(key_base, person=b'client', key=conf.hs_hello).digest()
	assert len(key_recv) == len(key_push) == conf.hs_key_size, [len(key_recv), len(key_push)]

	with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock_conn:
		sock_conn.settimeout(conf.hs_timeout)
		sock_conn.connect(('localhost', rsync_port))
		key = sock_conn.recv(conf.hs_key_size)
		if len(key) != conf.hs_key_size or key != key_push:
			raise SSHRsyncError('ssh/socket mismatch (len={}/{})', len(key), conf.hs_key_size)
		sock_conn.send(key_recv)

	return rsync_port, rsync_info


def main(args=None):
	conf = SSHRsyncReceiverConfig()

	import argparse, textwrap

	dedent = lambda text: (textwrap.dedent(text).strip('\n') + '\n').replace('\t', '  ')
	class SmartHelpFormatter(argparse.HelpFormatter):
		def __init__(self, *args, **kws):
			return super().__init__(*args, **kws, width=100)
		def _fill_text(self, text, width, indent):
			if '\n' not in text: return super()._fill_text(text, width, indent)
			return ''.join( indent + line
				for line in text.replace('\t', '  ').splitlines(keepends=True) )
		def _split_lines(self, text, width):
			return super()._split_lines(text, width)\
				if '\n' not in text else dedent(text).splitlines()

	parser = argparse.ArgumentParser(
		formatter_class=SmartHelpFormatter,
		description=dedent('''
			Receiver script for ssh sessions from ssh-r-sync.
			Should be run after successful ssh auth to check reverse-tunnel setup,
				perform any necessary maintenance on destination path and run rsync client.'''),
		epilog=dedent('''
			sshd_config snippet to set this script for backup-user command:

				Match User backup
					# GatewayPorts yes
					PasswordAuthentication no
					X11Forwarding no
					AllowAgentForwarding no
					PermitTTY no
					PermitTunnel no
					AllowStreamLocalForwarding no
					AllowTcpForwarding remote
					ForceCommand ~/ssh-r-sync-recv -m -- /mnt/backups

			Any cli opts of this script should be added to ForceCommand.
			Authentication is done via usual lines in ~backup/.ssh/authorized_keys'''))
	# XXX: allow to use as shell, with backup_dir set to home-dir
	parser.add_argument('backup_dir', help='Destination backup directory path.')
	parser.add_argument('-r', '--rsync', metavar='path',
		help='Path to custom rsync binary, e.g. one with all necessary posix caps enabled.')
	parser.add_argument('-m', '--manifest',
		nargs='?', metavar='name', const='_manifest.txt',
		help='Generate manifest file with specified name'
				' (default: %(default)s) in the synced directories.'
			' Created by single "find -printf ..." command with'
				' custom format, including various file/path stats/attributes.')
	# XXX: option for touching/removing backup-done file
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	ssh = SSHPipe(
		recv=open(sys.stdin.fileno(), 'rb', 0),
		send=open(sys.stdout.fileno(), 'wb', 0) )
	sys.stdin = sys.stdout = None

	# XXX: backup dir handling/rotation
	bak_path = pl.Path(opts.backup_dir).resolve()

	rsync_port, rsync_info = get_rsync_info(conf, ssh)

	cmd = ssh.recv.readline().rstrip(b'\n')
	if cmd != b'start': raise SSHRsyncError('Invalid/missing backup command: {!r}', cmd)

	rsync = subprocess.run(
		[ pl.Path(opts.rsync).resolve() if opts.rsync else 'rsync',
			*(['-HaAXS', '--super', '--numeric-ids'] if rsync_info.su else ['-rltHE']),
			( '--skip-compress='
				r'gz/bz2/t\[gb\]z/tbz2/xz/lzma/7z/zip/rar'
				r'/rpm/deb/iso'
				r'/jpg/gif/png/mov/avi/og\[gv\]/mkv/webm/mp\[34g\]/flv/flac/ape/pdf/djvu' ),
			f'rsync://{rsync_info.user}@localhost:{rsync_port}/{rsync_info.mod}/.',
			str(bak_path / '.') ],
		env=dict(RSYNC_PASSWORD=rsync_info.key) ) # XXX: check popen kws
	if rsync.returncode != 0:
		raise SSHRsyncError('Rsync process exited with non-zero code: {}', rsync.returncode)

	if opts.manifest:
		with tempfile.NamedTemporaryFile(
				dir=bak_path, prefix=opts.manifest + '.', delete=False ) as tmp:
			try:
				subprocess.run(
					['find', '-printf', '%P :: %Y:%l :: %U:%G:%m :: %s :: %T@\n'],
					stdout=tmp, cwd=bak_path, check=True)
				os.rename(tmp.name, bak_path / opts.manifest)
			finally:
				with contextlib.suppress(OSError): os.unlink(tmp.name)

	ssh.send.write(b'done\n')
	ssh.send.close()

if __name__ == '__main__': sys.exit(main())
